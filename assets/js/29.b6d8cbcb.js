(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{484:function(v,_,t){"use strict";t.r(_);var a=t(8),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"向量的量化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#向量的量化"}},[v._v("#")]),v._v(" 向量的量化")]),v._v(" "),_("p",[v._v("QuantFunction(X) = (Clip(Round(X/scale) + offset) - offset) * Scale")]),v._v(" "),_("h3",{attrs:{id:"算子的量化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算子的量化"}},[v._v("#")]),v._v(" 算子的量化")]),v._v(" "),_("p",[v._v("算子：向量到向量的映射")]),v._v(" "),_("p",[v._v("在输入和输出的时候进行量化")]),v._v(" "),_("p",[v._v("Input|Op|Output")]),v._v(" "),_("p",[v._v("但是不是所有的都是，例如Aerage Pooling，Reshape")]),v._v(" "),_("ul",[_("li",[v._v("有不能量化的参数；")]),v._v(" "),_("li",[v._v("有不能量化的输出；")]),v._v(" "),_("li",[v._v("输入和输出要求相同的scale；")])]),v._v(" "),_("p",[v._v("量化框架需要知道每一种算子的量化规则；")]),v._v(" "),_("h3",{attrs:{id:"网络量化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络量化"}},[v._v("#")]),v._v(" 网络量化")]),v._v(" "),_("p",[v._v("算子的集合体。")]),v._v(" "),_("ul",[_("li",[v._v("关闭冗余量化信息；")]),v._v(" "),_("li",[v._v("图融合；")])]),v._v(" "),_("h3",{attrs:{id:"如何部署"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何部署"}},[v._v("#")]),v._v(" 如何部署")]),v._v(" "),_("p",[v._v("推理框架需要 scale + offset，需要导出这几种格式携带；")]),v._v(" "),_("ul",[_("li",[v._v("onnx + QDQ Node")]),v._v(" "),_("li",[v._v("Onnx + Json File")]),v._v(" "),_("li",[v._v("Onnx + Quantized Op")])]),v._v(" "),_("h3",{attrs:{id:"常见的推理框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的推理框架"}},[v._v("#")]),v._v(" 常见的推理框架")]),v._v(" "),_("ul",[_("li",[v._v("TensorRT")]),v._v(" "),_("li",[v._v("NCNN")]),v._v(" "),_("li",[v._v("SNPE")]),v._v(" "),_("li",[v._v("PPL")]),v._v(" "),_("li",[v._v("ONNXRUNTIME")]),v._v(" "),_("li",[v._v("Openvino")]),v._v(" "),_("li",[v._v("RKNN")])]),v._v(" "),_("h4",{attrs:{id:"推理框架的集中输入模型格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#推理框架的集中输入模型格式"}},[v._v("#")]),v._v(" 推理框架的集中输入模型格式")]),v._v(" "),_("ul",[_("li",[v._v("Pytorch（.pth）")]),v._v(" "),_("li",[v._v("Onnx+Json（.onnx,.json）适合分发")]),v._v(" "),_("li",[v._v("Binary")])]),v._v(" "),_("h3",{attrs:{id:"量化误差"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#量化误差"}},[v._v("#")]),v._v(" 量化误差")]),v._v(" "),_("p",[v._v("INT8 = Clip(Round(X/scale) + offset")]),v._v(" "),_("p",[v._v("OX = （INT8 - Offset）*Scale")]),v._v(" "),_("p",[v._v("Error = ||X - QX|| / ||X||")]),v._v(" "),_("p",[v._v("量化对才追求后面精度。")])])}),[],!1,null,null,null);_.default=s.exports}}]);